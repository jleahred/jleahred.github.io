<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>jle_cpp_tk: lib_core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="jleahred2s.jpeg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">jle_cpp_tk
   &#160;<span id="projectnumber">0.0  2015-04-03  sh1:&quot;bfef736926b62bf7cb5f149b615ab514f55fab17&quot;</span>
   </div>
   <div id="projectbrief">A small, safe, selft contained, soft-realtime C++ toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_src_core_core.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">lib_core </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="smart_pointers"></a>
smart_pointers</h1>
<h2>shared_ptr</h2>
<p>Safe shared_ptr wrapper</p>
<p>Same interface as std::shared_ptr but, with no undefined behaviour</p>
<p>links:</p><ul>
<li>see: <a class="el" href="classjle_1_1shared__ptr.html" title="A safe std smart pointer WRAPPER. ">jle::shared_ptr</a></li>
<li>example: <a class="el" href="_2core_2ex_shared_ptr_8cpp-example.html">/core/ex_shared_ptr.cpp</a></li>
</ul>
<h2>weak_ptr</h2>
<p>Safe weak_ptr wrapper</p>
<p>Same interface as std::shared_ptr but, with no undefined behaviour</p>
<p>links:</p><ul>
<li>see: <a class="el" href="classjle_1_1weak__ptr.html" title="A safe std weak_ptr WRAPPER. ">jle::weak_ptr</a></li>
<li>example: <a class="el" href="_2core_2ex_shared_ptr_8cpp-example.html">/core/ex_shared_ptr.cpp</a></li>
<li>header: <a class="el" href="shared__ptr_8hpp_source.html">/core/shared_ptr.hpp</a></li>
</ul>
<h1><a class="anchor" id="test"></a>
test</h1>
<p>Some macros and functions to help with test <a class="el" href="test_8h_source.html">core/test.h</a></p>
<p>See on examples/core/test_shared_ptr.cpp</p>
<p>briefly...</p>
<table class="doxtable">
<tr>
<th>Macro </th><th>Description  </th></tr>
<tr>
<td>JLE_TEST_FILE: </td><td>at the begining of execution file </td></tr>
<tr>
<td>JLE_TEST_REPORT: </td><td>at the end of execution file </td></tr>
<tr>
<td>JLE_TEST_INIT: </td><td>at the beggining of a test (generally a function) </td></tr>
<tr>
<td>JLE_TEST_ASSERT: </td><td>check truth and write a dot </td></tr>
<tr>
<td>JLE_TEST_ASSERT_NO_DOT: </td><td>check truth without writting a dot </td></tr>
<tr>
<td>JLE_TEST_EXCEPTION: </td><td>check expression throws an exception </td></tr>
</table>
<p>links:</p><ul>
<li>example: <a class="el" href="_2core_2ex_test_8cpp-example.html">/core/ex_test.cpp</a></li>
<li>header: <a class="el" href="test_8h_source.html">/core/test.h</a></li>
</ul>
<h1><a class="anchor" id="string"></a>
string</h1>
<h2>Concatenation JLE_SS</h2>
<p>Code like...</p>
<div class="fragment"><div class="line">std::string s = <span class="stringliteral">&quot;asdfds&quot;</span> + var1 + var2 + <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p>is very dangerous and limited.</p>
<p>We like...</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;asdfds&quot;</span> &lt;&lt; var1 &lt;&lt; var2 &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>That is safer and powerful.</p>
<p>Please, never use <code>+</code> to concat strings. My proposal is...</p>
<div class="fragment"><div class="line">JLE_SS(<span class="stringliteral">&quot;asdfds&quot;</span> &lt;&lt; var1 &lt;&lt; var2 &lt;&lt; std::endl);</div>
</div><!-- fragment --><p><b>JLE_SS</b> will produce a <code>ostringstream</code> with all it powers (and safer than +), therefore more expressive</p>
<h2>Converting</h2>
<p>s_try_sxxx Convert an string to integer, double, duration, time point...</p>
<p>You can provide a value in case conversion fail. It will return a tuple with the converted value or the default and a boolean indicating if conversion was right</p>
<p>Another utilities are...</p>
<ul>
<li>Trimming</li>
<li>Align</li>
<li>Splitting</li>
</ul>
<p>links:</p><ul>
<li>example: <a class="el" href="_2core_2ex_jle_ss_8cpp-example.html">/core/ex_jle_ss.cpp</a></li>
<li>example: <a class="el" href="_2core_2ex_jle_string_8cpp-example.html">/core/ex_jle_string.cpp</a></li>
<li>header: <a class="el" href="string_8h_source.html">/core/string.h</a></li>
</ul>
<h1><a class="anchor" id="signal_slot"></a>
signal_slot</h1>
<p>An good event system is great in order to compose. signal_slot is a static event system (good performance and strict compiling type check)</p>
<p>I wrote one years before. I had to deal with optional parameters on templates. This implementation worked with 0 till 4 parameters. In order to add parameters, was necesary to modify the code. Very similar code. Yes, it was methaprograming and it was copy/paste (disgusting)</p>
<p>Today, with modern C++, I wrote it with variadic templates. Fantastic experience. Quite easy, and it works with several parameters</p>
<p>If composition with events is not enought for you, signals are also fully RAII. When signal or receiver is out of scope, signals are disconnected. You don't have to take care of disconnection before exit (destructor), neither disconnection to avoid orphan live references (problem for counter ptrs and garbage collectors)</p>
<h2>Connection syntax recomendations...</h2>
<table class="doxtable">
<tr>
<th>Connection </th><th>Syntax  </th></tr>
<tr>
<td>signal -&gt; function </td><td>signal.connect(on_function_name); </td></tr>
<tr>
<td>signal -&gt; method </td><td>JLE_CONNECT_METHOD(signal, instance, on_method); </td></tr>
<tr>
<td>signal -&gt; method on this </td><td>JLE_CONNECT_THIS(signal, on_method); </td></tr>
<tr>
<td>signal -&gt; signal </td><td>signal.connect(&amp;signal_receiver); </td></tr>
</table>
<h2>Performance</h2>
<p>In my computer with no params, you can emit arround 200.000 signals per second...</p>
<p>Executing... <a class="el" href="">/core/signal_slot_performance.cpp</a> </p><pre class="fragment"> &gt; ---------------------------------------------------------------------
 add int loop

 1783293664
 time: 0.000598493
 calls/millisecond: 1.67086e+06
 ---------------------------------------------------------------------
 signal -&gt; function (emit)

 time: 0.00495689
 calls/millisecond: 201740
 ---------------------------------------------------------------------
 signal -&gt; function (no emit)

 time: 0.00491906
 calls/millisecond: 203291
 ---------------------------------------------------------------------
 signal -&gt; método  (emit)

 time: 0.00461001
 calls/millisecond: 216919
 ---------------------------------------------------------------------
 direct call function

 1000000
 time: 9.1e-08
 too fast...
 ---------------------------------------------------------------------
 signal -&gt; function

 1000000
 time: 0.00556662
 calls/millisecond: 179642
</pre><p>links:</p><ul>
<li>see: <a class="el" href="classjle_1_1signal.html" title="signal instance to connect and emit ">jle::signal</a> <a class="el" href="classjle_1_1signal__receptor.html" title="Any object connected to signals, has to inherit from signal_receptor. ">jle::signal_receptor</a></li>
<li>example: <a class="el" href="_2core_2ex_signal_slot_8cpp-example.html">/core/ex_signal_slot.cpp</a></li>
<li>header: <a class="el" href="signal__slot_8hpp_source.html">/core/signal_slot.hpp</a></li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd><b>What if you destroy the signal while it is emiting?</b> <br />
 This is not a specific signal_slot pattern problem <br />
 It's possible to manage this situation in a safe way with signals, but is an incomplete solution. <br />
 The params could be references or raw pointers (please, do not use raw pointers) and they could be out of scope when signal is destroyed. Providing a partial solution is not a good idea. In case you do something similar, a message will be emmited on cerr <br />
 It will be added asynchronous signals. They we'll deal with this situations with no problem, but they will requiere copy on params.</dd>
<dd>
<b>What if an exception is thrown processing a signal?</b> <br />
 At the moment, it is not managed. The exception will break the control flow not emiting the last connected signals. <br />
 This looks logical. An exception is an exception. I'm thinking about the option on trapping the exception and rethrow a new one after finishing signaling. But I'm not sure it is a good idea.</dd>
<dd>
<b>Probably you know a lambda is a function</b> <br />
 Even when you assign to a variable, the function keep existing and signal is never disconnected automatically (it's a function).</dd></dl>
<p>You can connect signals to lambdas (as connecting to functions). <br />
 If you are surprised with problems connecting to lambdas who capture scope... this is good. <br />
 Capturing scope is not a good idea and new mechanisms are provided in C++14.</p>
<h1><a class="anchor" id="chrono"></a>
chrono</h1>
<p><b>std::chrono</b> is great, but it's very flexible and therefore verbose.</p>
<p>For realtime applications, I need a precisse monotonic clock.</p>
<p>PC clock is not precisse at all. And system clock syncroniced with ntp is not guaranteed to be monotonic.</p>
<p><b>jle::time_point</b> will be monotonic ant it will syncrhonize with system clock slowly. Except once per day.</p>
<p>using jle::chono (<code>#include "core/chrono.h"</code>), is a bit intrusive...</p>
<ul>
<li>It will add <code>using namespace std::literals;</code> in order to use time literals as <code>1s + 123ms</code></li>
<li>It will define <code>operator&lt;&lt;</code> on <code>stream</code> for <code>duration</code></li>
</ul>
<p>To reduce verbosity, there are proposed some helpers</p>
<ul>
<li><code><a class="el" href="structjle_1_1chrono_1_1duration.html">jle::chrono::duration</a></code></li>
<li><code>jle::chrono::now()</code></li>
<li><code>jle::chrono::make_from_date(const year&amp;, const month&amp;, const day&amp;)</code></li>
</ul>
<p>As usual, take a look to examples.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>micro-adjustments and one big adjustment per day</dd></dl>
<p>links:</p><ul>
<li>see: <a class="el" href="classjle_1_1chrono_1_1time__point.html" title="similar to std::chrono::time_point but monotonic with adjustments to system_clock ...">jle::chrono::time_point</a></li>
<li>example: <a class="el" href="_2core_2ex_chrono_8cpp-example.html">/core/ex_chrono.cpp</a></li>
<li>header: <a class="el" href="chrono_8h_source.html">/core/chrono.h</a></li>
</ul>
<h1><a class="anchor" id="alarm"></a>
alarm</h1>
<p>C++, in case of an exception, will not inform you about the call stack.</p>
<p>We have the exception type. It's great, but we don't have nested calls.</p>
<p>We can not force the compiler to inform about the stack call when an exception is raised, but we can give you the opportunity to stack errors information.</p>
<p>links:</p><ul>
<li>see: <a class="el" href="structjle_1_1alarm.html">jle::alarm</a></li>
<li>example: <a class="el" href="_2core_2ex_alarm_8cpp-example.html">/core/ex_alarm.cpp</a></li>
<li>header: <a class="el" href="alarm_8h_source.html">/core/alarm.h</a></li>
</ul>
<h1><a class="anchor" id="dbl"></a>
dbl</h1>
<p>IEEE754 is great but isn't infinite accurate.</p>
<p>There are two risk.</p>
<ul>
<li>Rounds with conmutativity and asociativity operations</li>
<li>Base ten exact values that are periodic on binary</li>
</ul>
<p><a href="http://joseluisestebanaparicio.blogspot.com.es/2008/04/el-famoso-formato-ieee754.html">http://joseluisestebanaparicio.blogspot.com.es/2008/04/el-famoso-formato-ieee754.html</a></p>
<p>See also:</p><ul>
<li><a class="el" href="namespacejle.html#a88196a8f001228c2d1b130c67963c667" title="as double version std:: ">jle::log</a></li>
<li><a class="el" href="namespacejle.html#a2545076c58990fafd2282c7e7d83e9ea" title="as double version std:: ">jle::pow</a></li>
<li><a class="el" href="namespacejle.html#a0e6583a02cd43547ec4182b83e45687a" title="Get number of decimals base 10 (aprox) ">jle::get_decimals10</a></li>
</ul>
<p>Using ''-Wfloat-equal'' helps a lot, but we want to compare in a quite safe way. This is <a class="el" href="classjle_1_1dbl.html">jle::dbl</a> for.</p>
<p>links:</p><ul>
<li>see: <a class="el" href="classjle_1_1dbl.html">jle::dbl</a></li>
<li>example: <a class="el" href="_2core_2ex_dbl_8cpp-example.html">/core/ex_dbl.cpp</a></li>
<li>header: <a class="el" href="dbl_8h_source.html">/core/dbl.h</a></li>
</ul>
<h1><a class="anchor" id="containers"></a>
containers</h1>
<p>stl containers are great, but not safe.</p>
<p>Iterators on stl::containers could dangle and they could generate indefined behaviour.</p>
<p>In order to avoid it with moderate performance penalty, jle library will check the validity of iterators with "fail fast" pattern.</p>
<p>It looks a bad idea to keep iterators when the container has been modified, adding or removing elements. It isn't very expensive to track iterators on these conditions.</p>
<p>jle will throw an exception on invalid iterator operations (instead of undefined behaviour)...</p>
<ul>
<li>Iterator pointing a modifyed container (added or removed elements)</li>
<li>Iterators on empty containers</li>
<li>Derrefering end iterator</li>
<li>Comparing iterators from different containers</li>
</ul>
<p>jle::containers are wrappers to stl containers with iterators verification</p>
<p>See also:</p>
<p>links:</p><ul>
<li><a class="el" href="classjle_1_1vector.html">jle::vector</a></li>
<li><a class="el" href="classjle_1_1list.html">jle::list</a></li>
<li><a class="el" href="classjle_1_1map.html">jle::map</a></li>
<li><a class="el" href="classjle_1_1set.html">jle::set</a></li>
<li>example: <a class="el" href="_2core_2ex_container_8cpp-example.html">/core/ex_container.cpp</a></li>
<li>headers:<ul>
<li><a class="el" href="vector_8hpp_source.html">/core/cont/vector.hpp</a></li>
<li><a class="el" href="list_8hpp_source.html">/core/cont/list.hpp</a></li>
<li><a class="el" href="map_8hpp_source.html">/core/cont/map.hpp</a></li>
<li><a class="el" href="set_8hpp_source.html">/core/cont/set.hpp</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="optional"></a>
optional</h1>
<p>I could contain a value, it could not contain a value...</p>
<p>This is a safe std::experimental::optional wrapper. No undefined behaviour</p>
<p>Some years ago, I wrote something similar with the name of nullable.</p>
<p>The right way to do it, is using algebraic data types. But, we don't have it in C++.</p>
<p>I was thinking of working with algebraic data types with templates and macros, but finally, I decided to postpone it to the sdl to define data structs.</p>
<p>But this is a common, basic, core and very frecuently needed, therefore, here it is the optional type.</p>
<p>links:</p><ul>
<li>see: <a class="el" href="classjle_1_1optional.html" title="Class template for optional values. ">jle::optional</a></li>
<li>example: <a class="el" href="_2core_2ex_optional_8cpp-example.html">/core/ex_optional.cpp</a></li>
</ul>
<h1><a class="anchor" id="tuple"></a>
tuple</h1>
<p>Now we have tuples on C++, but I want to write them at stream.</p>
<p>jle::tuple is not a wrapper, it is just an alias to std::tuple</p>
<p>When you include <a class="el" href="tuple_8hpp_source.html">core/tuple.hpp</a> it will inject ostream &lt;&lt; support on tuples.</p>
<p>As this is a bit invasive, we created the alias jle::tuple. If you see jle::tuple, you know it has ostream&lt;&lt; suport</p>
<p>links:</p><ul>
<li>see: <a class="el" href="tuple_8hpp_source.html">core/tuple.hpp</a></li>
<li>example: <a class="el" href="">/core/ex_tuple.cpp</a></li>
</ul>
<h1><a class="anchor" id="timers"></a>
timers</h1>
<p>It is part or message driven programming.</p>
<p>Only one line is necessary to configure a timer, check the example.</p>
<p>links:</p><ul>
<li>see: <a class="el" href="timer_8h_source.html">core/timer.h</a></li>
<li>example: <a class="el" href="_2core_2ex_timer_8cpp-example.html">/core/ex_timer.cpp</a></li>
</ul>
<h1><a class="anchor" id="synchr"></a>
synchr</h1>
<p>I don't try to run several threads in a safe way in C++</p>
<p>In fact, I do the opposite.</p>
<p>With this library, you can run multiple threads sequentially.</p>
<p>If you use a third party library with other thread callbacks, or if you want to run passive waiting (and you need a thread), you can call JLE_SYNCR to avoid having more than one thread running simultaneously.</p>
<p>Also you have here the way to start and stop the jle mail loop.</p>
<p>links:</p><ul>
<li>see: <a class="el" href="synchr_8h_source.html">core/synchr.h</a> - example: <a class="el" href="">/core/ex_synchr.cpp</a></li>
</ul>
<h1><a class="anchor" id="int_div0"></a>
int_div0</h1>
<p>In most hardware platforms, dividing by 0 two integers is a big problem.</p>
<p>On x86, it stops the program without exception or any warning.</p>
<p>To avoid this "undefined behavior" with bad result, you can use</p>
<p>JLE_HANDLE_INTDIV0 macros. See the example.</p>
<p>links:</p><ul>
<li>see: <a class="el" href="int__div0_8h_source.html">core/int_div0.h</a></li>
<li>example: <a class="el" href="_2core_2ex_int_div0_8cpp-example.html">/core/ex_int_div0.cpp</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Feb 20 2016 23:11:47 for jle_cpp_tk by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
